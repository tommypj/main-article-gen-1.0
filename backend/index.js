// 1. Încarcă variabilele de mediu din fișierul .env (doar pentru dezvoltare locală)
// În Cloud Functions, variabilele de mediu sunt injectate automat de platformă.
require('dotenv').config();

// 2. Importă Modulele Necesare
const admin = require('firebase-admin'); 
const express = require('express');
const cors = require('cors'); 
const helmet = require('helmet'); 
const compression = require('compression'); 
const rateLimit = require('express-rate-limit'); 
const asyncHandler = require('express-async-handler'); 

const { config } = require('./config/config'); 
const { logger, createTimer } = require('./utils/logger'); 
const InputValidator = require('./validators/validators'); 
const GeminiService = require('./services/geminiService'); 

// Client pentru Secret Manager - necesar pentru a prelua cheia API la startup
const { SecretManagerServiceClient } = require('@google-cloud/secret-manager');
const secretManagerClient = new SecretManagerServiceClient();

// ADDED: Initialize Firebase Admin SDK with the explicit project ID
// This projectId MUST match the 'aud' claim in the token generated by your frontend.
// Your Firebase web app config shows "carina-s-blog".
admin.initializeApp({
  projectId: "carina-s-blog" // <--- CRITICAL CHANGE: Set this to the projectId from your frontend config
});
console.log('index.js: Firebase Admin SDK initialized with projectId:', "carina-s-blog");


// 3. Inițializarea Aplicației Express
const app = express();
app.set('trust proxy', 1); 

// Inițializarea serviciilor și validatoarelor
const inputValidator = new InputValidator();
const geminiService = new GeminiService();

// ADDED: Middleware pentru autentificarea utilizatorului
const authenticateUser = async (req, res, next) => {
    console.log('index.js: authenticateUser middleware started.');
    // Development bypass: REMOVE THIS IN PRODUCTION OR WHEN TESTING REAL AUTH
    if (config.app.nodeEnv === 'development' && !req.headers.authorization) {
        req.user = { uid: 'test_user_id_dev' }; 
        logger.warn('Authentication skipped for development mode. Using test_user_id_dev.');
        console.log('index.js: Auth bypass active for dev mode. User UID:', req.user.uid);
        return next();
    }

    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        logger.warn('Authentication: Missing or invalid Authorization header.');
        console.warn('index.js: Missing or invalid Authorization header.');
        return res.status(401).json({ error: 'Autentificare necesară. Token lipsă sau format incorect.' });
    }

    const idToken = authHeader.split('Bearer ')[1];
    console.log('index.js: Received ID token (first 20 chars):', idToken.substring(0, 20) + '...');

    try {
        const decodedToken = await admin.auth().verifyIdToken(idToken);
        req.user = decodedToken; 
        console.log('index.js: ID token verified successfully. User UID:', req.user.uid);
        next();
    } catch (error) {
        logger.error('Authentication: Invalid ID token', { error: error.message, idToken });
        console.error('index.js: ID token verification failed:', error.message);
        return res.status(403).json({ error: `Autentificare eșuată. Token invalid sau expirat. Detalii: ${error.message}` });
    }
};


// Funcție pentru a prelua cheia API la startup
async function getGeminiApiKey() {
    console.log('index.js: getGeminiApiKey called.');
    const projectId = config.getProjectId(); 
    if (!projectId) {
        throw new Error('Project ID is not set. Please ensure GCP_PROJECT environment variable is set in Cloud Functions.');
    }
    const name = `projects/${projectId}/secrets/${config.app.secretName}/versions/latest`;
    logger.info(`Attempting to access secret: ${name}`);
    console.log('index.js: Attempting to access secret:', name);
    try {
        const [version] = await secretManagerClient.accessSecretVersion({ name });
        console.log('index.js: Secret accessed successfully.');
        return version.payload.data.toString('utf8');
    }
    catch (error) {
        logger.error('Failed to access secret from Secret Manager', { 
            error: error.message, 
            secretName: config.app.secretName 
        });
        console.error('index.js: Failed to access secret from Secret Manager:', error.message);
        throw new Error(`Failed to access API key from Secret Manager: ${error.message}. Check secret name and IAM permissions.`);
    }
}

// 4. Inițializare globală a API-ului Gemini (se întâmplă o singură dată la pornirea aplicației)
async function globalGeminiInitialization() {
    console.log('index.js: globalGeminiInitialization started.');
    try {
        logger.info('Starting global Gemini service initialization...');
        const apiKey = await getGeminiApiKey();
        await geminiService.initialize(apiKey);
        geminiService.initialized = true; 
        logger.info('Global GeminiService initialization complete.');
        console.log('index.js: Global GeminiService initialization complete.');
    } catch (error) {
        geminiService.initializationError = error; 
        logger.error('Critical: Failed global Gemini service initialization.', { 
            error: error.message 
        });
        console.error('index.js: Critical: Failed global Gemini service initialization.', error.message);
    }
}

// Apelăm inițializarea globală (nu blocăm serverul)
globalGeminiInitialization();
console.log('index.js: globalGeminiInitialization called (non-blocking).');


// 5. Middleware-uri Globale
app.use(helmet()); 
app.use(compression()); 

// Configurare CORS
app.use(cors({
    origin: config.app.allowedOrigins, 
    methods: ['GET', 'POST', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'], 
    credentials: true
}));
console.log('index.js: CORS middleware configured.');


// Configurare Rate Limiting - exclus health check
const apiLimiter = rateLimit({
    windowMs: config.rateLimit.windowMs,
    max: config.rateLimit.max,
    message: 'Prea multe cereri de la această adresă IP, te rog încearcă din nou mai târziu.',
    skipSuccessfulRequests: config.rateLimit.skipSuccessfulRequests,
    skip: (req) => req.path === '/health' 
});
app.use(apiLimiter);
console.log('index.js: Rate Limiting middleware configured.');

// Parser pentru corpul cererilor JSON
app.use(express.json({ limit: config.app.jsonLimit }));
console.log('index.js: JSON parser middleware configured.');


// 6. Middleware pentru verificarea inițializării serviciului Gemini
const checkInitialization = (req, res, next) => {
    console.log('index.js: checkInitialization middleware started. Gemini service initialized:', geminiService.initialized);
    if (!geminiService.initialized) {
        if (geminiService.initializationError) {
            logger.error('Request blocked: Service unavailable due to initialization error.', { error: geminiService.initializationError.message });
            console.error('index.js: Service unavailable due to initialization error:', geminiService.initializationError.message);
            return res.status(500).json({ 
                error: 'Serviciul este indisponibil din cauza unei erori de inițializare.',
                details: geminiService.initializationError.message
            });
        }
        logger.warn('Request blocked: Service initializing.');
        console.warn('index.js: Request blocked: Service initializing.');
        return res.status(503).json({ 
            error: 'Serviciul se inițializează. Te rog încearcă din nou în câteva secunde.' 
        });
    }
    next();
};


// 7. Definirea Rutelor

// Rută Health Check (fără rate limiting și fără verificarea inițializării)
app.get('/health', (req, res) => {
    logger.info('Health check endpoint hit');
    console.log('index.js: Health check endpoint hit.');
    const status = geminiService.initialized ? 'healthy' : (geminiService.initializationError ? 'unhealthy' : 'initializing');
    res.json({ 
        status, 
        timestamp: new Date().toISOString(),
        geminiServiceInitialized: geminiService.initialized,
        initializationError: geminiService.initializationError ? geminiService.initializationError.message : null,
        message: geminiService.initialized 
            ? 'All systems nominal' 
            : (geminiService.initializationError ? 'Initialization failed' : 'Gemini service still initializing')
    });
});

// Rută principală pentru generarea articolului (POST /)
app.post('/', checkInitialization, authenticateUser, asyncHandler(async (req, res) => { 
    logger.info('Article generation request received', { body: req.body });
    console.log('index.js: Article generation request received. Action:', req.body.action);
    
    let validatedBody;
    try {
        validatedBody = inputValidator.validateArticleRequest(req.body);
        logger.info('Input validation successful', { body: validatedBody });
        console.log('index.js: Input validation successful.');
    } catch (validationError) {
        logger.warn('Input validation failed', { 
            error: validationError.message, 
            input: req.body 
        });
        console.warn('index.js: Input validation failed:', validationError.message);
        return res.status(400).json({ error: validationError.message });
    }

    const { action, subject, articleContent, sectionTitle } = validatedBody;
    const userId = req.user.uid; 
    console.log('index.js: Request for action:', action, 'by userId:', userId);

    try {
        let responseData;

        switch (action) {
            case 'generateArticle':
                logger.info(`[START] Incepe generarea articolului pentru subiectul: "${subject}" pentru user ${userId}`);
                console.log(`index.js: Starting article generation for subject: "${subject}" for user ${userId}`);
                responseData = await geminiService.generateArticle(subject, userId); 
                logger.info('Article generation completed successfully', { subject: responseData.finalSubject, seoScore: responseData.seoAnalysis?.scor_general, userId });
                console.log('index.js: Article generation completed successfully.');
                break;

            case 'summarizeArticle':
                if (!articleContent) {
                    console.warn('index.js: Summarize request missing articleContent.');
                    return res.status(400).json({ error: 'Conținutul articolului este necesar pentru rezumat.' });
                }
                logger.info(`[START] Incepe generarea rezumatului pentru user ${userId}`);
                console.log(`index.js: Starting summary generation for user ${userId}`);
                const summary = await geminiService.summarizeArticle(articleContent, userId);
                responseData = { summary };
                logger.info('Article summary generated successfully.', { userId });
                console.log('index.js: Article summary generated successfully.');
                break;

            case 'expandSection':
                if (!articleContent || !sectionTitle) {
                    console.warn('index.js: Expand section request missing content or title.');
                    return res.status(400).json({ error: 'Conținutul articolului și titlul secțiunii sunt necesare pentru extindere.' });
                }
                logger.info(`[START] Incepe extinderea secțiunii: "${sectionTitle}" pentru user ${userId}`);
                console.log(`index.js: Starting section expansion for "${sectionTitle}" for user ${userId}`);
                const expandedContent = await geminiService.expandSection(articleContent, sectionTitle, userId);
                responseData = { expandedContent };
                logger.info(`Section "${sectionTitle}" expanded successfully.`, { userId });
                console.log(`index.js: Section "${sectionTitle}" expanded successfully.`);
                break;

            default:
                console.warn('index.js: Invalid action specified:', action);
                return res.status(400).json({ error: 'Acțiune invalidă specificată.' });
        }
        
        console.log('index.js: Sending response to frontend.');
        return res.json({ success: true, ...responseData });

    } catch (error) {
        logger.error('Failed to process request', { 
            error: error.message, 
            stack: error.stack, 
            action, 
            subject,
            userId 
        });
        console.error('index.js: Request processing failed:', error.message);
        
        if (error.message.includes('API key') || error.message.includes('Secret Manager')) {
            return res.status(500).json({ error: 'Eroare de configurare a cheii API. Verificați logurile funcției Cloud.' });
        }
        
        if (error.message.includes('Eroare la procesarea Etapa') || 
            error.message.includes('Răspuns invalid') || 
            error.message.includes('Răspuns gol')) {
            return res.status(500).json({ 
                error: `Eroare la interpretarea răspunsului AI într-o etapă intermediară. Te rog încearcă din nou.` 
            });
        }
        
        if (error.message.includes('timeout')) {
            return res.status(504).json({ 
                error: 'Generarea articolului durează prea mult. Te rog încearcă din nou.' 
            });
        }
        
        if (error.code) { 
            if (error.code === 404) {
                return res.status(500).json({ error: `Eroare API Gemini: Modelul (${config.gemini.model}) nu a fost găsit sau nu este suportat în regiunea dvs. Asigurați-vă că Vertex AI API este activat și cotele sunt suficiente.` });
            }
            if (error.code === 429 || error.code === 503) {
                return res.status(429).json({ error: 'Serviciul Gemini este supraîncărcat sau indisponibil temporar. Te rog încearcă din nou în câteva minute.' });
            }
            if (error.code === 400) {
                return res.status(400).json({ error: `Eroare API Gemini: Cerere invalidă. Detalii: ${error.details || error.message}.` });
            }
            if (error.code === 401 || error.code === 403) {
                return res.status(403).json({ error: 'Permisiuni insuficiente pentru API-ul Gemini. Verifică rolurile contului de serviciu (Vertex AI User).' });
            }
            return res.status(500).json({ error: `Eroare API Gemini: Cod ${error.code}. Te rog încearcă din nou. Detalii: ${error.details || error.message}.` });
        } 
        
        return res.status(500).json({ 
            error: `A apărut o eroare neașteptată la generarea articolului: ${error.message || 'Eroare necunoscută.'}. Te rog încearcă din nou mai târziu.` 
        });
    }
}));

// Gestionarea rutelor inexistente (404 Not Found)
app.use((req, res, next) => { 
    logger.warn('404 Not Found for URL', { url: req.originalUrl, method: req.method });
    console.warn('index.js: 404 Not Found for URL:', req.originalUrl);
    res.status(404).json({ error: 'Ruta nu a fost găsită.' });
});

// Global error handler (ultimul middleware pentru a prinde erorile AsyncHandler)
app.use((err, req, res, next) => { 
    console.error('index.js: Global error handler caught an error:', err.message);
    console.error('index.js: Error stack:', err.stack);
    console.error('Eroare prinsă de handler-ul global:', { 
        error: err.message, 
        stack: err.stack 
    });
    res.status(err.status || 500).json({ 
        error: 'Eroare internă de server. Te rog contactează suportul.' 
    });
});

// Exportă aplicația Express pentru Cloud Functions
exports.app = app;